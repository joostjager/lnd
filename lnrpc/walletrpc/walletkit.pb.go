// Code generated by protoc-gen-go. DO NOT EDIT.
// source: walletkit.proto

/*
Package walletrpc is a generated protocol buffer package.

It is generated from these files:
	walletkit.proto

It has these top-level messages:
	KeyReq
	AddrRequest
	AddrResponse
	Transaction
	PublishResponse
	SpendReport
	OutPoint
	SendOutputsRequest
	SendOutputsResponse
	EstimateFeeRequest
	EstimateFeeResponse
*/
package walletrpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import signrpc "github.com/lightningnetwork/lnd/lnrpc/signrpc"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type KeyReq struct {
	// *
	// Is the key finger print of the root pubkey that this request is targeting.
	// This allows the WalletKit to possibly serve out keys for multiple HD chains
	// via public derivation.
	KeyFingerPrint int32 `protobuf:"varint,1,opt,name=key_finger_print,json=keyFingerPrint" json:"key_finger_print,omitempty"`
	// *
	// The target key family to derive a key from. In other contexts, this is
	// known as the "account".
	KeyFamily int32 `protobuf:"varint,2,opt,name=key_family,json=keyFamily" json:"key_family,omitempty"`
}

func (m *KeyReq) Reset()                    { *m = KeyReq{} }
func (m *KeyReq) String() string            { return proto.CompactTextString(m) }
func (*KeyReq) ProtoMessage()               {}
func (*KeyReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *KeyReq) GetKeyFingerPrint() int32 {
	if m != nil {
		return m.KeyFingerPrint
	}
	return 0
}

func (m *KeyReq) GetKeyFamily() int32 {
	if m != nil {
		return m.KeyFamily
	}
	return 0
}

type AddrRequest struct {
}

func (m *AddrRequest) Reset()                    { *m = AddrRequest{} }
func (m *AddrRequest) String() string            { return proto.CompactTextString(m) }
func (*AddrRequest) ProtoMessage()               {}
func (*AddrRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type AddrResponse struct {
	// *
	// The address encoded using a bech32 format.
	Addr string `protobuf:"bytes,1,opt,name=addr" json:"addr,omitempty"`
}

func (m *AddrResponse) Reset()                    { *m = AddrResponse{} }
func (m *AddrResponse) String() string            { return proto.CompactTextString(m) }
func (*AddrResponse) ProtoMessage()               {}
func (*AddrResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *AddrResponse) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type Transaction struct {
	// *
	// The raw serialized transaction.
	TxHex []byte `protobuf:"bytes,1,opt,name=tx_hex,json=txHex,proto3" json:"tx_hex,omitempty"`
}

func (m *Transaction) Reset()                    { *m = Transaction{} }
func (m *Transaction) String() string            { return proto.CompactTextString(m) }
func (*Transaction) ProtoMessage()               {}
func (*Transaction) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Transaction) GetTxHex() []byte {
	if m != nil {
		return m.TxHex
	}
	return nil
}

type PublishResponse struct {
	// *
	// If blank, then no error occurred and the transaction was successfully
	// published. If not the empty string, then a string representation of the
	// broadcast error.
	//
	// TODO(roasbeef): map to a proper enum type
	PublishError string `protobuf:"bytes,1,opt,name=publish_error,json=publishError" json:"publish_error,omitempty"`
}

func (m *PublishResponse) Reset()                    { *m = PublishResponse{} }
func (m *PublishResponse) String() string            { return proto.CompactTextString(m) }
func (*PublishResponse) ProtoMessage()               {}
func (*PublishResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *PublishResponse) GetPublishError() string {
	if m != nil {
		return m.PublishError
	}
	return ""
}

type SpendReport struct {
	// *
	// If true, then this outpoint has been spent a confirmed or unconfirmed
	// transaction within the internal transaction store of the wallet.
	HasSpend bool `protobuf:"varint,1,opt,name=has_spend,json=hasSpend" json:"has_spend,omitempty"`
	// *
	// The raw transaction that spends the target outpoint. Note that this will
	// only be populated if the above field returns true.
	RawTxHex []byte `protobuf:"bytes,2,opt,name=raw_tx_hex,json=rawTxHex,proto3" json:"raw_tx_hex,omitempty"`
}

func (m *SpendReport) Reset()                    { *m = SpendReport{} }
func (m *SpendReport) String() string            { return proto.CompactTextString(m) }
func (*SpendReport) ProtoMessage()               {}
func (*SpendReport) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *SpendReport) GetHasSpend() bool {
	if m != nil {
		return m.HasSpend
	}
	return false
}

func (m *SpendReport) GetRawTxHex() []byte {
	if m != nil {
		return m.RawTxHex
	}
	return nil
}

type OutPoint struct {
	// *
	// The txid of the transaction that produced this output.
	Txid []byte `protobuf:"bytes,1,opt,name=txid,proto3" json:"txid,omitempty"`
	// *
	// The index of the output within the transaction above that is being
	// referenced.
	Index int32 `protobuf:"varint,2,opt,name=index" json:"index,omitempty"`
}

func (m *OutPoint) Reset()                    { *m = OutPoint{} }
func (m *OutPoint) String() string            { return proto.CompactTextString(m) }
func (*OutPoint) ProtoMessage()               {}
func (*OutPoint) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *OutPoint) GetTxid() []byte {
	if m != nil {
		return m.Txid
	}
	return nil
}

func (m *OutPoint) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

type SendOutputsRequest struct {
	// *
	// The number of satoshis per kilo weight that should be used when crafting
	// this transaction.
	SatPerKw int64 `protobuf:"varint,1,opt,name=sat_per_kw,json=satPerKw" json:"sat_per_kw,omitempty"`
	// *
	// A slice of the outputs that should be created in the transaction produced.
	Outputs []*signrpc.TxOut `protobuf:"bytes,2,rep,name=outputs" json:"outputs,omitempty"`
}

func (m *SendOutputsRequest) Reset()                    { *m = SendOutputsRequest{} }
func (m *SendOutputsRequest) String() string            { return proto.CompactTextString(m) }
func (*SendOutputsRequest) ProtoMessage()               {}
func (*SendOutputsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *SendOutputsRequest) GetSatPerKw() int64 {
	if m != nil {
		return m.SatPerKw
	}
	return 0
}

func (m *SendOutputsRequest) GetOutputs() []*signrpc.TxOut {
	if m != nil {
		return m.Outputs
	}
	return nil
}

type SendOutputsResponse struct {
	// *
	// The txid of the transaction sent out on the network.
	Txid []byte `protobuf:"bytes,1,opt,name=txid,proto3" json:"txid,omitempty"`
}

func (m *SendOutputsResponse) Reset()                    { *m = SendOutputsResponse{} }
func (m *SendOutputsResponse) String() string            { return proto.CompactTextString(m) }
func (*SendOutputsResponse) ProtoMessage()               {}
func (*SendOutputsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *SendOutputsResponse) GetTxid() []byte {
	if m != nil {
		return m.Txid
	}
	return nil
}

type EstimateFeeRequest struct {
	// *
	// The number of confirmations to shoot for when estimating the fee.
	ConfTarget int32 `protobuf:"varint,1,opt,name=conf_target,json=confTarget" json:"conf_target,omitempty"`
}

func (m *EstimateFeeRequest) Reset()                    { *m = EstimateFeeRequest{} }
func (m *EstimateFeeRequest) String() string            { return proto.CompactTextString(m) }
func (*EstimateFeeRequest) ProtoMessage()               {}
func (*EstimateFeeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *EstimateFeeRequest) GetConfTarget() int32 {
	if m != nil {
		return m.ConfTarget
	}
	return 0
}

type EstimateFeeResponse struct {
	// *
	// The amount of satoshis per kw that should be used in order to reach the
	// confirmation target in the request.
	SatPerKw int64 `protobuf:"varint,2,opt,name=sat_per_kw,json=satPerKw" json:"sat_per_kw,omitempty"`
}

func (m *EstimateFeeResponse) Reset()                    { *m = EstimateFeeResponse{} }
func (m *EstimateFeeResponse) String() string            { return proto.CompactTextString(m) }
func (*EstimateFeeResponse) ProtoMessage()               {}
func (*EstimateFeeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *EstimateFeeResponse) GetSatPerKw() int64 {
	if m != nil {
		return m.SatPerKw
	}
	return 0
}

func init() {
	proto.RegisterType((*KeyReq)(nil), "walletrpc.KeyReq")
	proto.RegisterType((*AddrRequest)(nil), "walletrpc.AddrRequest")
	proto.RegisterType((*AddrResponse)(nil), "walletrpc.AddrResponse")
	proto.RegisterType((*Transaction)(nil), "walletrpc.Transaction")
	proto.RegisterType((*PublishResponse)(nil), "walletrpc.PublishResponse")
	proto.RegisterType((*SpendReport)(nil), "walletrpc.SpendReport")
	proto.RegisterType((*OutPoint)(nil), "walletrpc.OutPoint")
	proto.RegisterType((*SendOutputsRequest)(nil), "walletrpc.SendOutputsRequest")
	proto.RegisterType((*SendOutputsResponse)(nil), "walletrpc.SendOutputsResponse")
	proto.RegisterType((*EstimateFeeRequest)(nil), "walletrpc.EstimateFeeRequest")
	proto.RegisterType((*EstimateFeeResponse)(nil), "walletrpc.EstimateFeeResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for WalletKit service

type WalletKitClient interface {
	// *
	// DeriveNextKey attempts to derive the *next* key within the key family
	// (account in BIP43) specified. This method should return the next external
	// child within this branch.
	DeriveNextKey(ctx context.Context, in *KeyReq, opts ...grpc.CallOption) (*signrpc.KeyDescriptor, error)
	// *
	// DeriveKey attempts to derive an arbitrary key specified by the passed
	// KeyLocator.
	DeriveKey(ctx context.Context, in *signrpc.KeyLocator, opts ...grpc.CallOption) (*signrpc.KeyDescriptor, error)
	// *
	// NextAddr returns the next unused address within the wallet.
	NextAddr(ctx context.Context, in *AddrRequest, opts ...grpc.CallOption) (*AddrResponse, error)
	// *
	// Attempts to publish the passed transaction to the network. Once this
	// returns without an error, the wallet will continually attempt to
	// re-broadcast the transaction on start up, until it enters the chain.
	PublishTransaction(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*PublishResponse, error)
	// *
	// HasSpendingTx returns a report detailing if there exists a
	// confirmed/unconfirmed transaction the wallet is aware of that spends the
	// passed outpoint.
	HasSpendingTx(ctx context.Context, in *OutPoint, opts ...grpc.CallOption) (*SpendReport, error)
	// *
	// SendOutputs is similar to the existing sendmany call in Bitcoind, and
	// allows the caller to create a transaction that sends to several outputs at
	// once. This is ideal when wanting to batch create a set of transactions.
	SendOutputs(ctx context.Context, in *SendOutputsRequest, opts ...grpc.CallOption) (*SendOutputsResponse, error)
	// *
	// EstimateFee attempts to query the internal fee estimator of the wallet to
	// determine the fee (in sat/kw) to attach to a transaction in order to
	// achieve the confirmation target.
	EstimateFee(ctx context.Context, in *EstimateFeeRequest, opts ...grpc.CallOption) (*EstimateFeeResponse, error)
}

type walletKitClient struct {
	cc *grpc.ClientConn
}

func NewWalletKitClient(cc *grpc.ClientConn) WalletKitClient {
	return &walletKitClient{cc}
}

func (c *walletKitClient) DeriveNextKey(ctx context.Context, in *KeyReq, opts ...grpc.CallOption) (*signrpc.KeyDescriptor, error) {
	out := new(signrpc.KeyDescriptor)
	err := grpc.Invoke(ctx, "/walletrpc.WalletKit/DeriveNextKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletKitClient) DeriveKey(ctx context.Context, in *signrpc.KeyLocator, opts ...grpc.CallOption) (*signrpc.KeyDescriptor, error) {
	out := new(signrpc.KeyDescriptor)
	err := grpc.Invoke(ctx, "/walletrpc.WalletKit/DeriveKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletKitClient) NextAddr(ctx context.Context, in *AddrRequest, opts ...grpc.CallOption) (*AddrResponse, error) {
	out := new(AddrResponse)
	err := grpc.Invoke(ctx, "/walletrpc.WalletKit/NextAddr", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletKitClient) PublishTransaction(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*PublishResponse, error) {
	out := new(PublishResponse)
	err := grpc.Invoke(ctx, "/walletrpc.WalletKit/PublishTransaction", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletKitClient) HasSpendingTx(ctx context.Context, in *OutPoint, opts ...grpc.CallOption) (*SpendReport, error) {
	out := new(SpendReport)
	err := grpc.Invoke(ctx, "/walletrpc.WalletKit/HasSpendingTx", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletKitClient) SendOutputs(ctx context.Context, in *SendOutputsRequest, opts ...grpc.CallOption) (*SendOutputsResponse, error) {
	out := new(SendOutputsResponse)
	err := grpc.Invoke(ctx, "/walletrpc.WalletKit/SendOutputs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletKitClient) EstimateFee(ctx context.Context, in *EstimateFeeRequest, opts ...grpc.CallOption) (*EstimateFeeResponse, error) {
	out := new(EstimateFeeResponse)
	err := grpc.Invoke(ctx, "/walletrpc.WalletKit/EstimateFee", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for WalletKit service

type WalletKitServer interface {
	// *
	// DeriveNextKey attempts to derive the *next* key within the key family
	// (account in BIP43) specified. This method should return the next external
	// child within this branch.
	DeriveNextKey(context.Context, *KeyReq) (*signrpc.KeyDescriptor, error)
	// *
	// DeriveKey attempts to derive an arbitrary key specified by the passed
	// KeyLocator.
	DeriveKey(context.Context, *signrpc.KeyLocator) (*signrpc.KeyDescriptor, error)
	// *
	// NextAddr returns the next unused address within the wallet.
	NextAddr(context.Context, *AddrRequest) (*AddrResponse, error)
	// *
	// Attempts to publish the passed transaction to the network. Once this
	// returns without an error, the wallet will continually attempt to
	// re-broadcast the transaction on start up, until it enters the chain.
	PublishTransaction(context.Context, *Transaction) (*PublishResponse, error)
	// *
	// HasSpendingTx returns a report detailing if there exists a
	// confirmed/unconfirmed transaction the wallet is aware of that spends the
	// passed outpoint.
	HasSpendingTx(context.Context, *OutPoint) (*SpendReport, error)
	// *
	// SendOutputs is similar to the existing sendmany call in Bitcoind, and
	// allows the caller to create a transaction that sends to several outputs at
	// once. This is ideal when wanting to batch create a set of transactions.
	SendOutputs(context.Context, *SendOutputsRequest) (*SendOutputsResponse, error)
	// *
	// EstimateFee attempts to query the internal fee estimator of the wallet to
	// determine the fee (in sat/kw) to attach to a transaction in order to
	// achieve the confirmation target.
	EstimateFee(context.Context, *EstimateFeeRequest) (*EstimateFeeResponse, error)
}

func RegisterWalletKitServer(s *grpc.Server, srv WalletKitServer) {
	s.RegisterService(&_WalletKit_serviceDesc, srv)
}

func _WalletKit_DeriveNextKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletKitServer).DeriveNextKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/walletrpc.WalletKit/DeriveNextKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletKitServer).DeriveNextKey(ctx, req.(*KeyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletKit_DeriveKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(signrpc.KeyLocator)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletKitServer).DeriveKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/walletrpc.WalletKit/DeriveKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletKitServer).DeriveKey(ctx, req.(*signrpc.KeyLocator))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletKit_NextAddr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddrRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletKitServer).NextAddr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/walletrpc.WalletKit/NextAddr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletKitServer).NextAddr(ctx, req.(*AddrRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletKit_PublishTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletKitServer).PublishTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/walletrpc.WalletKit/PublishTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletKitServer).PublishTransaction(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletKit_HasSpendingTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OutPoint)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletKitServer).HasSpendingTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/walletrpc.WalletKit/HasSpendingTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletKitServer).HasSpendingTx(ctx, req.(*OutPoint))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletKit_SendOutputs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendOutputsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletKitServer).SendOutputs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/walletrpc.WalletKit/SendOutputs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletKitServer).SendOutputs(ctx, req.(*SendOutputsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletKit_EstimateFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EstimateFeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletKitServer).EstimateFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/walletrpc.WalletKit/EstimateFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletKitServer).EstimateFee(ctx, req.(*EstimateFeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _WalletKit_serviceDesc = grpc.ServiceDesc{
	ServiceName: "walletrpc.WalletKit",
	HandlerType: (*WalletKitServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DeriveNextKey",
			Handler:    _WalletKit_DeriveNextKey_Handler,
		},
		{
			MethodName: "DeriveKey",
			Handler:    _WalletKit_DeriveKey_Handler,
		},
		{
			MethodName: "NextAddr",
			Handler:    _WalletKit_NextAddr_Handler,
		},
		{
			MethodName: "PublishTransaction",
			Handler:    _WalletKit_PublishTransaction_Handler,
		},
		{
			MethodName: "HasSpendingTx",
			Handler:    _WalletKit_HasSpendingTx_Handler,
		},
		{
			MethodName: "SendOutputs",
			Handler:    _WalletKit_SendOutputs_Handler,
		},
		{
			MethodName: "EstimateFee",
			Handler:    _WalletKit_EstimateFee_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "walletkit.proto",
}

func init() { proto.RegisterFile("walletkit.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 599 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x54, 0x5d, 0x4f, 0xdb, 0x48,
	0x14, 0x15, 0x81, 0xb0, 0xc9, 0x35, 0x81, 0xdd, 0xc9, 0x2e, 0x8b, 0xdc, 0xd2, 0x22, 0xb7, 0x0f,
	0xe9, 0x4b, 0x22, 0x41, 0x5b, 0x55, 0xb4, 0x2f, 0x95, 0x00, 0x45, 0x0a, 0x2a, 0xa9, 0x89, 0xd4,
	0x97, 0x4a, 0xd6, 0x60, 0x5f, 0x9c, 0x51, 0xcc, 0x8c, 0x99, 0xb9, 0x6e, 0x9c, 0xbf, 0xdb, 0x5f,
	0x52, 0x79, 0xec, 0xa4, 0x0e, 0x94, 0x27, 0xcf, 0x9c, 0x39, 0xf7, 0xdc, 0xaf, 0x23, 0xc3, 0xde,
	0x9c, 0x27, 0x09, 0xd2, 0x4c, 0x50, 0x3f, 0xd5, 0x8a, 0x14, 0x6b, 0x97, 0x80, 0x4e, 0x43, 0xf7,
	0x34, 0x16, 0x34, 0xcd, 0x6e, 0xfa, 0xa1, 0xba, 0x1b, 0x24, 0x22, 0x9e, 0x92, 0x14, 0x32, 0x96,
	0x48, 0x73, 0xa5, 0x67, 0x83, 0x44, 0x46, 0x83, 0x44, 0xea, 0x34, 0x1c, 0x18, 0x11, 0xaf, 0xbe,
	0xa8, 0x4b, 0x19, 0xef, 0x2b, 0x6c, 0x8f, 0x70, 0xe1, 0xe3, 0x3d, 0xeb, 0xc1, 0xdf, 0x33, 0x5c,
	0x04, 0xb7, 0x42, 0xc6, 0xa8, 0x83, 0x54, 0x0b, 0x49, 0x07, 0x1b, 0x47, 0x1b, 0xbd, 0xa6, 0xbf,
	0x3b, 0xc3, 0xc5, 0x85, 0x85, 0xc7, 0x05, 0xca, 0x0e, 0x01, 0x2c, 0x93, 0xdf, 0x89, 0x64, 0x71,
	0xd0, 0xb0, 0x9c, 0x76, 0xc1, 0xb1, 0x80, 0xd7, 0x01, 0xe7, 0x73, 0x14, 0x69, 0x1f, 0xef, 0x33,
	0x34, 0xe4, 0x79, 0xb0, 0x53, 0x5e, 0x4d, 0xaa, 0xa4, 0x41, 0xc6, 0x60, 0x8b, 0x47, 0x91, 0xb6,
	0xda, 0x6d, 0xdf, 0x9e, 0xbd, 0xd7, 0xe0, 0x4c, 0x34, 0x97, 0x86, 0x87, 0x24, 0x94, 0x64, 0xff,
	0xc1, 0x36, 0xe5, 0xc1, 0x14, 0x73, 0x4b, 0xda, 0xf1, 0x9b, 0x94, 0x0f, 0x31, 0xf7, 0xde, 0xc3,
	0xde, 0x38, 0xbb, 0x49, 0x84, 0x99, 0xae, 0xc4, 0x5e, 0x41, 0x27, 0x2d, 0xa1, 0x00, 0xb5, 0x56,
	0x4b, 0xd5, 0x9d, 0x0a, 0x3c, 0x2f, 0x30, 0x6f, 0x08, 0xce, 0x75, 0x8a, 0x32, 0xf2, 0x31, 0x55,
	0x9a, 0xd8, 0x33, 0x68, 0x4f, 0xb9, 0x09, 0x4c, 0x01, 0x59, 0x7e, 0xcb, 0x6f, 0x4d, 0xb9, 0xb1,
	0x14, 0xf6, 0x1c, 0x40, 0xf3, 0x79, 0x50, 0xa5, 0x6f, 0xd8, 0xf4, 0x2d, 0xcd, 0xe7, 0x13, 0x5b,
	0xc1, 0x5b, 0x68, 0x5d, 0x65, 0x34, 0x56, 0xc5, 0x14, 0x18, 0x6c, 0x51, 0x2e, 0xa2, 0xaa, 0x44,
	0x7b, 0x66, 0xff, 0x42, 0x53, 0xc8, 0xa8, 0x0a, 0x6c, 0xfa, 0xe5, 0xc5, 0xfb, 0x0e, 0xec, 0x1a,
	0x65, 0x74, 0x95, 0x51, 0x9a, 0x91, 0xa9, 0xe6, 0x52, 0x64, 0x32, 0x9c, 0x82, 0x14, 0x75, 0x30,
	0x9b, 0x5b, 0x95, 0x4d, 0xbf, 0x65, 0x38, 0x8d, 0x51, 0x8f, 0xe6, 0xac, 0x07, 0x7f, 0xa9, 0x92,
	0x7f, 0xd0, 0x38, 0xda, 0xec, 0x39, 0xc7, 0xbb, 0xfd, 0x6a, 0x7f, 0xfd, 0x49, 0x7e, 0x95, 0x91,
	0xbf, 0x7c, 0xf6, 0xde, 0x40, 0x77, 0x4d, 0xfd, 0xf7, 0x98, 0x1f, 0x96, 0xe7, 0xbd, 0x03, 0x76,
	0x6e, 0x48, 0xdc, 0x71, 0xc2, 0x0b, 0xc4, 0x65, 0x21, 0x2f, 0xc1, 0x09, 0x95, 0xbc, 0x0d, 0x88,
	0xeb, 0x18, 0x97, 0x3b, 0x87, 0x02, 0x9a, 0x58, 0xc4, 0x3b, 0x81, 0xee, 0x5a, 0x58, 0x95, 0x61,
	0xbd, 0x81, 0xc6, 0x7a, 0x03, 0xc7, 0x3f, 0x37, 0xa1, 0xfd, 0xcd, 0x5a, 0x74, 0x24, 0x88, 0x9d,
	0x42, 0xe7, 0x0c, 0xb5, 0xf8, 0x81, 0x5f, 0x30, 0xa7, 0x11, 0x2e, 0xd8, 0x3f, 0xfd, 0x95, 0x7f,
	0xfb, 0xa5, 0x01, 0xdd, 0xfd, 0x55, 0x87, 0x23, 0x5c, 0x9c, 0xa1, 0x09, 0xb5, 0x48, 0x49, 0x69,
	0xf6, 0x01, 0xda, 0x65, 0x6c, 0x11, 0xd7, 0xad, 0x93, 0x2e, 0x55, 0xc8, 0x49, 0xe9, 0x27, 0x23,
	0x3f, 0x42, 0xab, 0xc8, 0x57, 0xd8, 0x8f, 0xed, 0xd7, 0x12, 0xd6, 0xec, 0xe9, 0xfe, 0xff, 0x08,
	0xaf, 0xda, 0x1b, 0x02, 0xab, 0xdc, 0x56, 0xb7, 0x66, 0x5d, 0xa6, 0x86, 0xbb, 0x6e, 0x0d, 0x7f,
	0x68, 0xd2, 0x4f, 0xd0, 0x19, 0x56, 0xfe, 0x12, 0x32, 0x9e, 0xe4, 0xac, 0x5b, 0x23, 0x2f, 0xfd,
	0xe4, 0xd6, 0x95, 0xeb, 0x76, 0xbd, 0x04, 0xa7, 0xb6, 0x5f, 0x76, 0x58, 0xa7, 0x3d, 0x72, 0x95,
	0xfb, 0xe2, 0xa9, 0xe7, 0xaa, 0x96, 0x4b, 0x70, 0x6a, 0xbb, 0x5c, 0x53, 0x7b, 0x6c, 0x8d, 0x35,
	0xb5, 0x3f, 0x58, 0xe0, 0x66, 0xdb, 0xfe, 0x44, 0x4e, 0x7e, 0x05, 0x00, 0x00, 0xff, 0xff, 0xbf,
	0x0f, 0xb6, 0xd4, 0x9e, 0x04, 0x00, 0x00,
}
