syntax = "proto3";

import "rpc.proto";

package routerrpc;

option go_package = "github.com/lightningnetwork/lnd/lnrpc/routerrpc";

message PaymentRequest {
    /// The identity pubkey of the payment recipient
    bytes dest = 1;

    /// Number of satoshis to send.
    int64 amt = 2;

    /// The hash to use within the payment's HTLC
    bytes payment_hash = 3;
 
    /**
    The CLTV delta from the current height that should be used to set the
    timelock for the final hop.
    */
    int32 final_cltv_delta = 4;

    /**
    A bare-bones invoice for a payment within the Lightning Network.  With the
    details of the invoice, the sender has all the data necessary to send a
    payment to the recipient. The amount in the payment request may be zero. In
    that case it is required to set the amt field as well.
    */
    string payment_request = 5;

    /**
    An upper limit on the amount of time we should spend when attempting to
    fulfill the payment. This is expressed in seconds. If we cannot make a
    successful payment within this time frame, an error will be returned.
    This field must be non-zero.
    */
    int32 timeout_seconds = 6;

    /**
    The maximum number of satoshis that will be paid as a fee of the payment.
    If this field is left to the default value of 0, only zero-fee routes will
    be considered. This usually means single hop routes connecting directly to
    the destination. To send the payment without a fee limit, use max int here.
    */
    int64 fee_limit = 7;

    /**
    The channel id of the channel that must be taken to the first hop. If zero,
    any channel may be used.
    */
    uint64 outgoing_chan_id = 8;

    /** 
    An optional maximum total time lock for the route. If zero, there is no
    maximum enforced.
    */
    int32 cltv_limit = 9;
}

message PaymentResponse {
}

enum PaymentState {
    UNKNOWN = 0;
    IN_FLIGHT = 1;
    SUCCEEDED = 2;

    /**
    There are more routes to try, but the payment timeout was exceeded.
    */
    FAILED_TIMEOUT = 3;
    
    /**
    These errors originate from the destination node. Something is wrong with
    the invoice parameters.
    */
    FAILED_UNKNOWN_HASH = 4;
    FAILED_INVALID_AMT = 5;
    FAILED_INVALID_CLTV = 6;

    /**
    All possible routes were tried and failed permanently. Or were no
    routes to the destination at all.
    */
    FAILED_NO_ROUTE = 7;

    /**
    None of our channels had enough balance for the payment. This is a
    specific, actionable, case of FAILED_NO_ROUTE.
    */
    FAILED_LOCAL_LIQUIDITY = 8;
}


message PaymentStatus {
    /// Current state the payment is in.
    PaymentState state = 1;

    /**
    The pre-image of the payment when state is SUCCEEDED.
    */
    bytes preimage = 2;

    /**
    The taken route when state is SUCCEEDED.
    */
    lnrpc.Route route = 3;
}


message RouteFeeRequest {
    /**
    The destination once wishes to obtain a routing fee quote to.
    */
    bytes dest = 1;

    /**
    The amount one wishes to send to the target destination.
    */
    int64 amt_sat = 2;
}

message RouteFeeResponse {
    /**
    A lower bound of the estimated fee to the target destination within the
    network, expressed in milli-satoshis.
    */
    int64 routing_fee_msat = 1;

    /**
    An estimate of the worst case time delay that can occur. Note that callers
    will still need to factor in the final CLTV delta of the last hop into this
    value.
    */
    int64 time_lock_delay = 2;
}

service Router {
    /**
    SendPayment attempts to route a payment described by the passed
    PaymentRequest to the final destination. The call returns immediately.
    Further status information can be obtained through a LookupPayment stream.
    */
    rpc SendPayment(PaymentRequest) returns (PaymentResponse);

    /**
    LookupPayment returns an update stream for the payment identified by the
    payment hash. A first update will always be send over the stream
    immediately. If the payment is not known, it will report state UNKNOWN.
    */
    rpc LookupPayment(lnrpc.PaymentHash) returns (stream PaymentStatus);


    /**
    EstimateRouteFee allows callers to obtain a lower bound w.r.t how much it
    may cost to send an HTLC to the target end destination.
    */
    rpc EstimateRouteFee(RouteFeeRequest) returns (RouteFeeResponse);
}
