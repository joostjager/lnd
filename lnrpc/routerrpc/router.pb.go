// Code generated by protoc-gen-go. DO NOT EDIT.
// source: routerrpc/router.proto

package routerrpc // import "github.com/lightningnetwork/lnd/lnrpc/routerrpc"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import lnrpc "github.com/lightningnetwork/lnd/lnrpc"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type PaymentState int32

const (
	PaymentState_UNKNOWN   PaymentState = 0
	PaymentState_IN_FLIGHT PaymentState = 1
	PaymentState_SUCCEEDED PaymentState = 2
	// *
	// There are more routes to try, but the payment timeout was exceeded.
	PaymentState_FAILED_TIMEOUT PaymentState = 3
	// *
	// These errors originate from the destination node. Something is wrong with
	// the invoice parameters.
	PaymentState_FAILED_UNKNOWN_HASH PaymentState = 4
	PaymentState_FAILED_INVALID_AMT  PaymentState = 5
	PaymentState_FAILED_INVALID_CLTV PaymentState = 6
	// *
	// All possible routes were tried and failed permanently. Or were no
	// routes to the destination at all.
	PaymentState_FAILED_NO_ROUTE PaymentState = 7
	// *
	// None of our channels had enough balance for the payment. This is a
	// specific, actionable, case of FAILED_NO_ROUTE.
	PaymentState_FAILED_LOCAL_LIQUIDITY PaymentState = 8
)

var PaymentState_name = map[int32]string{
	0: "UNKNOWN",
	1: "IN_FLIGHT",
	2: "SUCCEEDED",
	3: "FAILED_TIMEOUT",
	4: "FAILED_UNKNOWN_HASH",
	5: "FAILED_INVALID_AMT",
	6: "FAILED_INVALID_CLTV",
	7: "FAILED_NO_ROUTE",
	8: "FAILED_LOCAL_LIQUIDITY",
}
var PaymentState_value = map[string]int32{
	"UNKNOWN":                0,
	"IN_FLIGHT":              1,
	"SUCCEEDED":              2,
	"FAILED_TIMEOUT":         3,
	"FAILED_UNKNOWN_HASH":    4,
	"FAILED_INVALID_AMT":     5,
	"FAILED_INVALID_CLTV":    6,
	"FAILED_NO_ROUTE":        7,
	"FAILED_LOCAL_LIQUIDITY": 8,
}

func (x PaymentState) String() string {
	return proto.EnumName(PaymentState_name, int32(x))
}
func (PaymentState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_router_bebc4448b18f40f8, []int{0}
}

type PaymentRequest struct {
	// / The identity pubkey of the payment recipient
	Dest []byte `protobuf:"bytes,1,opt,name=dest,proto3" json:"dest,omitempty"`
	// / Number of satoshis to send.
	Amt int64 `protobuf:"varint,2,opt,name=amt,proto3" json:"amt,omitempty"`
	// / The hash to use within the payment's HTLC
	PaymentHash []byte `protobuf:"bytes,3,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty"`
	// *
	// The CLTV delta from the current height that should be used to set the
	// timelock for the final hop.
	FinalCltvDelta int32 `protobuf:"varint,4,opt,name=final_cltv_delta,json=finalCltvDelta,proto3" json:"final_cltv_delta,omitempty"`
	// *
	// A bare-bones invoice for a payment within the Lightning Network.  With the
	// details of the invoice, the sender has all the data necessary to send a
	// payment to the recipient. The amount in the payment request may be zero. In
	// that case it is required to set the amt field as well.
	PaymentRequest string `protobuf:"bytes,5,opt,name=payment_request,json=paymentRequest,proto3" json:"payment_request,omitempty"`
	// *
	// An upper limit on the amount of time we should spend when attempting to
	// fulfill the payment. This is expressed in seconds. If we cannot make a
	// successful payment within this time frame, an error will be returned.
	// This field must be non-zero.
	TimeoutSeconds int32 `protobuf:"varint,6,opt,name=timeout_seconds,json=timeoutSeconds,proto3" json:"timeout_seconds,omitempty"`
	// *
	// The maximum number of satoshis that will be paid as a fee of the payment.
	// If this field is left to the default value of 0, only zero-fee routes will
	// be considered. This usually means single hop routes connecting directly to
	// the destination. To send the payment without a fee limit, use max int here.
	FeeLimit int64 `protobuf:"varint,7,opt,name=fee_limit,json=feeLimit,proto3" json:"fee_limit,omitempty"`
	// *
	// The channel id of the channel that must be taken to the first hop. If zero,
	// any channel may be used.
	OutgoingChanId uint64 `protobuf:"varint,8,opt,name=outgoing_chan_id,json=outgoingChanId,proto3" json:"outgoing_chan_id,omitempty"`
	// *
	// An optional maximum total time lock for the route. If zero, there is no
	// maximum enforced.
	CltvLimit            int32    `protobuf:"varint,9,opt,name=cltv_limit,json=cltvLimit,proto3" json:"cltv_limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PaymentRequest) Reset()         { *m = PaymentRequest{} }
func (m *PaymentRequest) String() string { return proto.CompactTextString(m) }
func (*PaymentRequest) ProtoMessage()    {}
func (*PaymentRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_router_bebc4448b18f40f8, []int{0}
}
func (m *PaymentRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PaymentRequest.Unmarshal(m, b)
}
func (m *PaymentRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PaymentRequest.Marshal(b, m, deterministic)
}
func (dst *PaymentRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaymentRequest.Merge(dst, src)
}
func (m *PaymentRequest) XXX_Size() int {
	return xxx_messageInfo_PaymentRequest.Size(m)
}
func (m *PaymentRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PaymentRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PaymentRequest proto.InternalMessageInfo

func (m *PaymentRequest) GetDest() []byte {
	if m != nil {
		return m.Dest
	}
	return nil
}

func (m *PaymentRequest) GetAmt() int64 {
	if m != nil {
		return m.Amt
	}
	return 0
}

func (m *PaymentRequest) GetPaymentHash() []byte {
	if m != nil {
		return m.PaymentHash
	}
	return nil
}

func (m *PaymentRequest) GetFinalCltvDelta() int32 {
	if m != nil {
		return m.FinalCltvDelta
	}
	return 0
}

func (m *PaymentRequest) GetPaymentRequest() string {
	if m != nil {
		return m.PaymentRequest
	}
	return ""
}

func (m *PaymentRequest) GetTimeoutSeconds() int32 {
	if m != nil {
		return m.TimeoutSeconds
	}
	return 0
}

func (m *PaymentRequest) GetFeeLimit() int64 {
	if m != nil {
		return m.FeeLimit
	}
	return 0
}

func (m *PaymentRequest) GetOutgoingChanId() uint64 {
	if m != nil {
		return m.OutgoingChanId
	}
	return 0
}

func (m *PaymentRequest) GetCltvLimit() int32 {
	if m != nil {
		return m.CltvLimit
	}
	return 0
}

type PaymentResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PaymentResponse) Reset()         { *m = PaymentResponse{} }
func (m *PaymentResponse) String() string { return proto.CompactTextString(m) }
func (*PaymentResponse) ProtoMessage()    {}
func (*PaymentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_router_bebc4448b18f40f8, []int{1}
}
func (m *PaymentResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PaymentResponse.Unmarshal(m, b)
}
func (m *PaymentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PaymentResponse.Marshal(b, m, deterministic)
}
func (dst *PaymentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaymentResponse.Merge(dst, src)
}
func (m *PaymentResponse) XXX_Size() int {
	return xxx_messageInfo_PaymentResponse.Size(m)
}
func (m *PaymentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PaymentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PaymentResponse proto.InternalMessageInfo

type PaymentStatus struct {
	// / Current state the payment is in.
	State PaymentState `protobuf:"varint,1,opt,name=state,proto3,enum=routerrpc.PaymentState" json:"state,omitempty"`
	// *
	// The pre-image of the payment when state is SUCCEEDED.
	Preimage []byte `protobuf:"bytes,2,opt,name=preimage,proto3" json:"preimage,omitempty"`
	// *
	// The taken route when state is SUCCEEDED.
	Route                *lnrpc.Route `protobuf:"bytes,3,opt,name=route,proto3" json:"route,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *PaymentStatus) Reset()         { *m = PaymentStatus{} }
func (m *PaymentStatus) String() string { return proto.CompactTextString(m) }
func (*PaymentStatus) ProtoMessage()    {}
func (*PaymentStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_router_bebc4448b18f40f8, []int{2}
}
func (m *PaymentStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PaymentStatus.Unmarshal(m, b)
}
func (m *PaymentStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PaymentStatus.Marshal(b, m, deterministic)
}
func (dst *PaymentStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaymentStatus.Merge(dst, src)
}
func (m *PaymentStatus) XXX_Size() int {
	return xxx_messageInfo_PaymentStatus.Size(m)
}
func (m *PaymentStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_PaymentStatus.DiscardUnknown(m)
}

var xxx_messageInfo_PaymentStatus proto.InternalMessageInfo

func (m *PaymentStatus) GetState() PaymentState {
	if m != nil {
		return m.State
	}
	return PaymentState_UNKNOWN
}

func (m *PaymentStatus) GetPreimage() []byte {
	if m != nil {
		return m.Preimage
	}
	return nil
}

func (m *PaymentStatus) GetRoute() *lnrpc.Route {
	if m != nil {
		return m.Route
	}
	return nil
}

type RouteFeeRequest struct {
	// *
	// The destination once wishes to obtain a routing fee quote to.
	Dest []byte `protobuf:"bytes,1,opt,name=dest,proto3" json:"dest,omitempty"`
	// *
	// The amount one wishes to send to the target destination.
	AmtSat               int64    `protobuf:"varint,2,opt,name=amt_sat,json=amtSat,proto3" json:"amt_sat,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteFeeRequest) Reset()         { *m = RouteFeeRequest{} }
func (m *RouteFeeRequest) String() string { return proto.CompactTextString(m) }
func (*RouteFeeRequest) ProtoMessage()    {}
func (*RouteFeeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_router_bebc4448b18f40f8, []int{3}
}
func (m *RouteFeeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RouteFeeRequest.Unmarshal(m, b)
}
func (m *RouteFeeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RouteFeeRequest.Marshal(b, m, deterministic)
}
func (dst *RouteFeeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteFeeRequest.Merge(dst, src)
}
func (m *RouteFeeRequest) XXX_Size() int {
	return xxx_messageInfo_RouteFeeRequest.Size(m)
}
func (m *RouteFeeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteFeeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RouteFeeRequest proto.InternalMessageInfo

func (m *RouteFeeRequest) GetDest() []byte {
	if m != nil {
		return m.Dest
	}
	return nil
}

func (m *RouteFeeRequest) GetAmtSat() int64 {
	if m != nil {
		return m.AmtSat
	}
	return 0
}

type RouteFeeResponse struct {
	// *
	// A lower bound of the estimated fee to the target destination within the
	// network, expressed in milli-satoshis.
	RoutingFeeMsat int64 `protobuf:"varint,1,opt,name=routing_fee_msat,json=routingFeeMsat,proto3" json:"routing_fee_msat,omitempty"`
	// *
	// An estimate of the worst case time delay that can occur. Note that callers
	// will still need to factor in the final CLTV delta of the last hop into this
	// value.
	TimeLockDelay        int64    `protobuf:"varint,2,opt,name=time_lock_delay,json=timeLockDelay,proto3" json:"time_lock_delay,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteFeeResponse) Reset()         { *m = RouteFeeResponse{} }
func (m *RouteFeeResponse) String() string { return proto.CompactTextString(m) }
func (*RouteFeeResponse) ProtoMessage()    {}
func (*RouteFeeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_router_bebc4448b18f40f8, []int{4}
}
func (m *RouteFeeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RouteFeeResponse.Unmarshal(m, b)
}
func (m *RouteFeeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RouteFeeResponse.Marshal(b, m, deterministic)
}
func (dst *RouteFeeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteFeeResponse.Merge(dst, src)
}
func (m *RouteFeeResponse) XXX_Size() int {
	return xxx_messageInfo_RouteFeeResponse.Size(m)
}
func (m *RouteFeeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteFeeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RouteFeeResponse proto.InternalMessageInfo

func (m *RouteFeeResponse) GetRoutingFeeMsat() int64 {
	if m != nil {
		return m.RoutingFeeMsat
	}
	return 0
}

func (m *RouteFeeResponse) GetTimeLockDelay() int64 {
	if m != nil {
		return m.TimeLockDelay
	}
	return 0
}

func init() {
	proto.RegisterType((*PaymentRequest)(nil), "routerrpc.PaymentRequest")
	proto.RegisterType((*PaymentResponse)(nil), "routerrpc.PaymentResponse")
	proto.RegisterType((*PaymentStatus)(nil), "routerrpc.PaymentStatus")
	proto.RegisterType((*RouteFeeRequest)(nil), "routerrpc.RouteFeeRequest")
	proto.RegisterType((*RouteFeeResponse)(nil), "routerrpc.RouteFeeResponse")
	proto.RegisterEnum("routerrpc.PaymentState", PaymentState_name, PaymentState_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RouterClient is the client API for Router service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RouterClient interface {
	// *
	// SendPayment attempts to route a payment described by the passed
	// PaymentRequest to the final destination. The call returns immediately.
	// Further status information can be obtained through a LookupPayment stream.
	SendPayment(ctx context.Context, in *PaymentRequest, opts ...grpc.CallOption) (*PaymentResponse, error)
	// *
	// LookupPayment returns an update stream for the payment identified by the
	// payment hash. A first update will always be send over the stream
	// immediately. If the payment is not known, it will report state UNKNOWN.
	LookupPayment(ctx context.Context, in *lnrpc.PaymentHash, opts ...grpc.CallOption) (Router_LookupPaymentClient, error)
	// *
	// EstimateRouteFee allows callers to obtain a lower bound w.r.t how much it
	// may cost to send an HTLC to the target end destination.
	EstimateRouteFee(ctx context.Context, in *RouteFeeRequest, opts ...grpc.CallOption) (*RouteFeeResponse, error)
}

type routerClient struct {
	cc *grpc.ClientConn
}

func NewRouterClient(cc *grpc.ClientConn) RouterClient {
	return &routerClient{cc}
}

func (c *routerClient) SendPayment(ctx context.Context, in *PaymentRequest, opts ...grpc.CallOption) (*PaymentResponse, error) {
	out := new(PaymentResponse)
	err := c.cc.Invoke(ctx, "/routerrpc.Router/SendPayment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) LookupPayment(ctx context.Context, in *lnrpc.PaymentHash, opts ...grpc.CallOption) (Router_LookupPaymentClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Router_serviceDesc.Streams[0], "/routerrpc.Router/LookupPayment", opts...)
	if err != nil {
		return nil, err
	}
	x := &routerLookupPaymentClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Router_LookupPaymentClient interface {
	Recv() (*PaymentStatus, error)
	grpc.ClientStream
}

type routerLookupPaymentClient struct {
	grpc.ClientStream
}

func (x *routerLookupPaymentClient) Recv() (*PaymentStatus, error) {
	m := new(PaymentStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *routerClient) EstimateRouteFee(ctx context.Context, in *RouteFeeRequest, opts ...grpc.CallOption) (*RouteFeeResponse, error) {
	out := new(RouteFeeResponse)
	err := c.cc.Invoke(ctx, "/routerrpc.Router/EstimateRouteFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RouterServer is the server API for Router service.
type RouterServer interface {
	// *
	// SendPayment attempts to route a payment described by the passed
	// PaymentRequest to the final destination. The call returns immediately.
	// Further status information can be obtained through a LookupPayment stream.
	SendPayment(context.Context, *PaymentRequest) (*PaymentResponse, error)
	// *
	// LookupPayment returns an update stream for the payment identified by the
	// payment hash. A first update will always be send over the stream
	// immediately. If the payment is not known, it will report state UNKNOWN.
	LookupPayment(*lnrpc.PaymentHash, Router_LookupPaymentServer) error
	// *
	// EstimateRouteFee allows callers to obtain a lower bound w.r.t how much it
	// may cost to send an HTLC to the target end destination.
	EstimateRouteFee(context.Context, *RouteFeeRequest) (*RouteFeeResponse, error)
}

func RegisterRouterServer(s *grpc.Server, srv RouterServer) {
	s.RegisterService(&_Router_serviceDesc, srv)
}

func _Router_SendPayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PaymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).SendPayment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/routerrpc.Router/SendPayment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).SendPayment(ctx, req.(*PaymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_LookupPayment_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(lnrpc.PaymentHash)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouterServer).LookupPayment(m, &routerLookupPaymentServer{stream})
}

type Router_LookupPaymentServer interface {
	Send(*PaymentStatus) error
	grpc.ServerStream
}

type routerLookupPaymentServer struct {
	grpc.ServerStream
}

func (x *routerLookupPaymentServer) Send(m *PaymentStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _Router_EstimateRouteFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteFeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).EstimateRouteFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/routerrpc.Router/EstimateRouteFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).EstimateRouteFee(ctx, req.(*RouteFeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Router_serviceDesc = grpc.ServiceDesc{
	ServiceName: "routerrpc.Router",
	HandlerType: (*RouterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendPayment",
			Handler:    _Router_SendPayment_Handler,
		},
		{
			MethodName: "EstimateRouteFee",
			Handler:    _Router_EstimateRouteFee_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "LookupPayment",
			Handler:       _Router_LookupPayment_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "routerrpc/router.proto",
}

func init() { proto.RegisterFile("routerrpc/router.proto", fileDescriptor_router_bebc4448b18f40f8) }

var fileDescriptor_router_bebc4448b18f40f8 = []byte{
	// 671 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x94, 0xdd, 0x6e, 0xd3, 0x30,
	0x14, 0xc7, 0xc9, 0xfa, 0x7d, 0xfa, 0x15, 0x3c, 0x69, 0x0b, 0x9d, 0x90, 0x4a, 0x2f, 0x58, 0x85,
	0x44, 0x0b, 0xe3, 0x1e, 0x54, 0x9a, 0x96, 0x46, 0xcb, 0xda, 0x91, 0xb6, 0x43, 0x70, 0x63, 0x79,
	0x89, 0xd7, 0x46, 0xcd, 0x17, 0x89, 0x33, 0xb4, 0x1b, 0x5e, 0x8c, 0x17, 0xe0, 0x21, 0x78, 0x18,
	0x64, 0xc7, 0xed, 0x0a, 0x4c, 0xdc, 0xd9, 0xbf, 0xe3, 0xf3, 0xcf, 0xf1, 0xff, 0xef, 0x16, 0x8e,
	0xe2, 0x30, 0x65, 0x34, 0x8e, 0x23, 0xbb, 0x9f, 0xad, 0x7a, 0x51, 0x1c, 0xb2, 0x10, 0x55, 0x76,
	0xbc, 0x55, 0x89, 0x23, 0x3b, 0xa3, 0x9d, 0x1f, 0x07, 0xd0, 0xb8, 0x24, 0x77, 0x3e, 0x0d, 0x98,
	0x45, 0xbf, 0xa6, 0x34, 0x61, 0x08, 0x41, 0xde, 0xa1, 0x09, 0xd3, 0x94, 0xb6, 0xd2, 0xad, 0x59,
	0x62, 0x8d, 0x54, 0xc8, 0x11, 0x9f, 0x69, 0x07, 0x6d, 0xa5, 0x9b, 0xb3, 0xf8, 0x12, 0x3d, 0x83,
	0x5a, 0x94, 0xf5, 0xe1, 0x35, 0x49, 0xd6, 0x5a, 0x4e, 0x9c, 0xae, 0x4a, 0x36, 0x21, 0xc9, 0x1a,
	0x75, 0x41, 0xbd, 0x71, 0x03, 0xe2, 0x61, 0xdb, 0x63, 0xb7, 0xd8, 0xa1, 0x1e, 0x23, 0x5a, 0xbe,
	0xad, 0x74, 0x0b, 0x56, 0x43, 0xf0, 0xa1, 0xc7, 0x6e, 0x75, 0x4e, 0xd1, 0x29, 0x34, 0xb7, 0x62,
	0x71, 0x36, 0x85, 0x56, 0x68, 0x2b, 0xdd, 0x8a, 0xd5, 0x88, 0xfe, 0x9c, 0xed, 0x14, 0x9a, 0xcc,
	0xf5, 0x69, 0x98, 0x32, 0x9c, 0x50, 0x3b, 0x0c, 0x9c, 0x44, 0x2b, 0x66, 0x8a, 0x12, 0xcf, 0x33,
	0x8a, 0x4e, 0xa0, 0x72, 0x43, 0x29, 0xf6, 0x5c, 0xdf, 0x65, 0x5a, 0x49, 0x8c, 0x5d, 0xbe, 0xa1,
	0xd4, 0xe4, 0x7b, 0x3e, 0x58, 0x98, 0xb2, 0x55, 0xe8, 0x06, 0x2b, 0x6c, 0xaf, 0x49, 0x80, 0x5d,
	0x47, 0x2b, 0xb7, 0x95, 0x6e, 0xde, 0x6a, 0x6c, 0xf9, 0x70, 0x4d, 0x02, 0xc3, 0x41, 0x4f, 0x01,
	0xc4, 0xf0, 0x99, 0x4e, 0x45, 0x7c, 0xaa, 0xc2, 0x89, 0x10, 0xea, 0x3c, 0x86, 0xe6, 0xce, 0xbc,
	0x24, 0x0a, 0x83, 0x84, 0x76, 0xbe, 0x43, 0x5d, 0xa2, 0x39, 0x23, 0x2c, 0x4d, 0xd0, 0x4b, 0x28,
	0x24, 0x8c, 0x30, 0x2a, 0xfc, 0x6c, 0x9c, 0x1d, 0xf7, 0x76, 0x39, 0xf4, 0xf6, 0x0e, 0x52, 0x2b,
	0x3b, 0x85, 0x5a, 0x50, 0x8e, 0x62, 0xea, 0xfa, 0x64, 0x45, 0x85, 0xdd, 0x35, 0x6b, 0xb7, 0x47,
	0x1d, 0x28, 0x88, 0x66, 0x61, 0x76, 0xf5, 0xac, 0xd6, 0xf3, 0x02, 0x2e, 0x63, 0x71, 0x66, 0x65,
	0xa5, 0xce, 0x5b, 0x68, 0x8a, 0xfd, 0x98, 0xd2, 0xff, 0x05, 0x7a, 0x0c, 0x25, 0xe2, 0x33, 0x9c,
	0x90, 0x6d, 0xa8, 0x45, 0xe2, 0xb3, 0x39, 0x61, 0x1d, 0x07, 0xd4, 0xfb, 0xfe, 0xec, 0x4e, 0xdc,
	0x2f, 0x2e, 0xce, 0xed, 0xe2, 0xa6, 0xfa, 0xbc, 0x4b, 0x11, 0x5d, 0x0d, 0xc9, 0xc7, 0x94, 0x5e,
	0x24, 0x84, 0xa1, 0xe7, 0x59, 0x3e, 0xd8, 0x0b, 0xed, 0x0d, 0x4f, 0x9c, 0xdc, 0x49, 0xf9, 0x3a,
	0xc7, 0x66, 0x68, 0x6f, 0x74, 0x0e, 0x5f, 0xfc, 0x54, 0xa0, 0xb6, 0x7f, 0x7b, 0x54, 0x85, 0xd2,
	0x72, 0x7a, 0x3e, 0x9d, 0x7d, 0x9a, 0xaa, 0x8f, 0x50, 0x1d, 0x2a, 0xc6, 0x14, 0x8f, 0x4d, 0xe3,
	0xc3, 0x64, 0xa1, 0x2a, 0x7c, 0x3b, 0x5f, 0x0e, 0x87, 0xa3, 0x91, 0x3e, 0xd2, 0xd5, 0x03, 0x84,
	0xa0, 0x31, 0x1e, 0x18, 0xe6, 0x48, 0xc7, 0x0b, 0xe3, 0x62, 0x34, 0x5b, 0x2e, 0xd4, 0x1c, 0x3a,
	0x86, 0x43, 0xc9, 0xa4, 0x0a, 0x9e, 0x0c, 0xe6, 0x13, 0x35, 0x8f, 0x8e, 0x00, 0xc9, 0x82, 0x31,
	0xbd, 0x1a, 0x98, 0x86, 0x8e, 0x07, 0x17, 0x0b, 0xb5, 0xb0, 0xd7, 0xb0, 0xe5, 0x43, 0x73, 0x71,
	0xa5, 0x16, 0xd1, 0x21, 0x34, 0x65, 0x61, 0x3a, 0xc3, 0xd6, 0x6c, 0xb9, 0x18, 0xa9, 0x25, 0xd4,
	0x82, 0x23, 0x09, 0xcd, 0xd9, 0x70, 0x60, 0x62, 0xd3, 0xf8, 0xb8, 0x34, 0x74, 0x63, 0xf1, 0x59,
	0x2d, 0x9f, 0xfd, 0x52, 0xa0, 0x28, 0x1c, 0x8b, 0x91, 0x0e, 0xd5, 0x39, 0x0d, 0x1c, 0x79, 0x31,
	0xf4, 0xe4, 0xdf, 0xa8, 0x65, 0x24, 0xad, 0xd6, 0x43, 0x25, 0xe9, 0xf6, 0x3b, 0xa8, 0x9b, 0x61,
	0xb8, 0x49, 0xa3, 0xad, 0x0e, 0x92, 0x39, 0x5f, 0xde, 0xff, 0xb6, 0x5a, 0xda, 0xc3, 0xcf, 0x28,
	0x4d, 0x5e, 0x29, 0xe8, 0x1c, 0xd4, 0x51, 0xc2, 0x5c, 0x9f, 0xbf, 0x2a, 0x19, 0x25, 0xda, 0xff,
	0xe0, 0x5f, 0xef, 0xa3, 0x75, 0xf2, 0x60, 0x2d, 0x9b, 0xe6, 0xfd, 0xeb, 0x2f, 0xfd, 0x95, 0xcb,
	0xd6, 0xe9, 0x75, 0xcf, 0x0e, 0xfd, 0xbe, 0xe7, 0xae, 0xd6, 0x2c, 0x70, 0x83, 0x55, 0x40, 0xd9,
	0xb7, 0x30, 0xde, 0xf4, 0xbd, 0xc0, 0xe9, 0x8b, 0xe9, 0xfa, 0x3b, 0x8d, 0xeb, 0xa2, 0xf8, 0x6b,
	0x79, 0xf3, 0x3b, 0x00, 0x00, 0xff, 0xff, 0xd4, 0x33, 0xee, 0x03, 0x8a, 0x04, 0x00, 0x00,
}
